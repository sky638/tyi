<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Young Internet</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .followers-section {
            background: white;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .section-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .section-header h2 {
            color: #333;
            margin-bottom: 5px;
            font-size: 1.8rem;
        }

        .section-header p {
            color: #666;
            font-size: 1rem;
        }

        .followers-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .follower-account {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
            text-decoration: none;
            transition: all 0.3s ease;
            display: inline-block;
            cursor: pointer;
        }

        .follower-account:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
            color: white;
            text-decoration: none;
        }

        .follower-account.selected {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            box-shadow: 0 3px 10px rgba(40, 167, 69, 0.3);
        }

        .follower-account.selected:hover {
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.5);
        }

        .filters {
            background: white;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 20px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-group label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #444;
        }

        .filter-group input, .filter-group select {
            padding: 12px;
            border: 2px solid #e1e1e1;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .filter-group input:focus, .filter-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .range-input {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .range-input input {
            flex: 1;
            /* Remove number input spinners/arrows for all browsers */
            -moz-appearance: textfield;
            appearance: textfield;
        }

        /* Chrome, Safari, Edge, Opera */
        .range-input input::-webkit-outer-spin-button,
        .range-input input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .filter-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #666;
            border: 2px solid #e1e1e1;
        }

        .btn-secondary:hover {
            background: #e9ecef;
        }

        .results {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .results-count {
            font-size: 1.2rem;
            font-weight: 600;
            color: #444;
        }

        .sort-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .sort-controls select {
            padding: 8px 12px;
            border: 2px solid #e1e1e1;
            border-radius: 8px;
            font-size: 14px;
        }

        .data-grid {
            display: grid;
            gap: 20px;
        }

        .data-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
            border: 1px solid #e1e1e1;
        }

        .data-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .username {
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
            text-decoration: none;
        }

        .username:hover {
            text-decoration: underline;
        }

        .followers-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .category {
            background: #e3f2fd;
            color: #1976d2;
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 0.85rem;
            margin-bottom: 10px;
            display: inline-block;
        }

        .description {
            color: #666;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .meta-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-size: 0.9rem;
            color: #888;
        }

        .meta-info > div:first-child {
            display: flex;
            gap: 20px;
        }

        .follower-tag {
            display: inline-block;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            color: #667eea;
            margin: 0 2px;
            font-size: 0.85rem;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .no-results {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .no-results h3 {
            margin-bottom: 10px;
            font-size: 1.5rem;
        }

        .load-notice {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            color: #0c5460;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #e1e1e1;
            border-radius: 5px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .filter-grid {
                grid-template-columns: 1fr;
            }

            .results-header {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>The Young Internet</h1>
        </div>

        <div class="load-notice" id="loadNotice">
            ðŸš€ <strong>Loading Data:</strong> Fetching your Instagram dataset...
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="loadStatus">Initializing...</div>
        </div>

        <div class="followers-section" id="followersSection" style="display: none;">
            <div class="section-header">
                <h2>Active Followers</h2>
                <p>Accounts that are following others in this dataset</p>
            </div>
            <div class="followers-grid" id="followersGrid">
                <!-- Follower accounts will be populated here -->
            </div>
        </div>

        <div class="filters">
            <div class="filter-grid">
                <div class="filter-group">
                    <label for="searchInput">Search Username or Description</label>
                    <input type="text" id="searchInput" placeholder="Type to search...">
                </div>

                <div class="filter-group">
                    <label for="categoryFilter">Category</label>
                    <input type="text" id="categoryFilter" placeholder="Type category keywords, separated by commas (e.g. singer, rapper)">
                </div>

                <div class="filter-group">
                    <label>Followers Range</label>
                    <div class="range-input">
                        <input type="number" id="minFollowers" placeholder="Min">
                        <span>to</span>
                        <input type="number" id="maxFollowers" placeholder="Max">
                    </div>
                </div>
                <!-- Removed Following Range filter group -->
            </div>

            <div class="filter-actions">
                <button class="btn btn-primary" onclick="applyFilters()">Apply Filters</button>
                <button class="btn btn-secondary" onclick="clearFilters()">Clear All</button>
            </div>
        </div>

        <div class="results">
            <div class="results-header">
                <div class="results-count" id="resultsCount">Loading data...</div>
                <div class="sort-controls">
                    <label for="sortBy">Sort by:</label>
                    <select id="sortBy" onchange="applyFilters()">
                        <option value="pagerank_desc">PageRank (High to Low)</option>
                        <option value="pagerank_asc">PageRank (Low to High)</option>
                        <option value="original">Original Order</option>
                        <option value="followers_desc">Followers (High to Low)</option>
                        <option value="followers_asc">Followers (Low to High)</option>
                        <option value="username_asc">Username (A-Z)</option>
                        <option value="username_desc">Username (Z-A)</option>
                        <option value="following_desc">Following (High to Low)</option>
                        <option value="following_asc">Following (Low to High)</option>
                    </select>
                </div>
            </div>

            <div class="data-grid" id="dataGrid">
                <div class="loading">Loading Instagram data...</div>
            </div>
        </div>
    </div>

    <script>
let allData = [];
let filteredData = [];
let selectedFollowers = new Set(); // Track which followers are selected for filtering
let originalOrderMap = new Map();
let pageRankScores = new Map(); // Store PageRank scores for each account
let currentPage = 1;
const itemsPerPage = 50;        // URL to your JSON data file (local path for static hosting)
        const DATA_URL = 'database_mini.json';

        function calculatePageRank(selectedFollowersSet = null) {
            console.log('=== PageRank Calculation Start ===');
            console.log('Selected followers:', selectedFollowersSet ? Array.from(selectedFollowersSet) : 'null');
            
            // Build the graph based on followed_by relationships
            const graph = new Map();
            const allUsernames = new Set();
            
            // Initialize graph and collect all usernames
            allData.forEach(item => {
                if (item.userName) {
                    allUsernames.add(item.userName);
                    graph.set(item.userName, new Set());
                }
            });
            
            console.log('Initial usernames in dataset:', allUsernames.size);
            
            // Build the follower graph
            let relationshipsProcessed = 0;
            allData.forEach(item => {
                if (item.followed_by && Array.isArray(item.followed_by)) {
                    item.followed_by.forEach(follower => {
                        // If we have selected followers, only consider their connections
                        // If no followers are selected (null or empty set), consider ALL relationships
                        const shouldInclude = selectedFollowersSet === null || 
                                            selectedFollowersSet.size === 0 || 
                                            selectedFollowersSet.has(follower);
                        
                        if (shouldInclude) {
                            relationshipsProcessed++;
                            // Ensure the follower exists in the graph
                            if (!graph.has(follower)) {
                                graph.set(follower, new Set());
                                allUsernames.add(follower);
                            }
                            // Add the relationship: follower -> item.userName
                            graph.get(follower).add(item.userName);
                        }
                    });
                }
            });
            
            console.log('Relationships processed:', relationshipsProcessed);
            console.log('Total nodes in graph:', allUsernames.size);
            
            const userList = Array.from(allUsernames);
            const n = userList.length;
            
            if (n === 0) return new Map();
            
            // Initialize PageRank scores
            const scores = new Map();
            const newScores = new Map();
            userList.forEach(user => {
                scores.set(user, 1.0 / n);
                newScores.set(user, 0);
            });
            
            // PageRank parameters
            const dampingFactor = 0.85;
            const iterations = 50;
            const tolerance = 1e-6;
            
            // Run PageRank algorithm
            for (let iter = 0; iter < iterations; iter++) {
                let totalDiff = 0;
                
                // Reset new scores
                userList.forEach(user => newScores.set(user, (1 - dampingFactor) / n));
                
                // Calculate new scores
                userList.forEach(fromUser => {
                    const outLinks = graph.get(fromUser) || new Set();
                    const outDegree = outLinks.size;
                    
                    if (outDegree > 0) {
                        const contribution = (dampingFactor * scores.get(fromUser)) / outDegree;
                        outLinks.forEach(toUser => {
                            newScores.set(toUser, newScores.get(toUser) + contribution);
                        });
                    }
                });
                
                // Check for convergence and update scores
                userList.forEach(user => {
                    const diff = Math.abs(newScores.get(user) - scores.get(user));
                    totalDiff += diff;
                    scores.set(user, newScores.get(user));
                });
                
                if (totalDiff < tolerance) {
                    console.log(`PageRank converged after ${iter + 1} iterations`);
                    break;
                }
            }
            
            // Normalize scores to 0-100 range for better display
            const maxScore = Math.max(...scores.values());
            const minScore = Math.min(...scores.values());
            const range = maxScore - minScore;
            
            if (range > 0) {
                scores.forEach((score, user) => {
                    scores.set(user, ((score - minScore) / range) * 100);
                });
            }
            
            // Log top 5 scores for debugging
            const topScores = Array.from(scores.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            console.log('Top 5 PageRank scores:', topScores);
            console.log('=== PageRank Calculation End ===');
            
            return scores;
        }

        function updatePageRankScores() {
            pageRankScores = calculatePageRank(selectedFollowers);
            const contextMsg = selectedFollowers.size === 0 ? 'all relationships' : `${selectedFollowers.size} selected followers`;
            console.log(`Calculated PageRank for ${pageRankScores.size} users using ${contextMsg}`);
        }

        async function loadData() {
            updateStatus('Connecting to data source...');
            updateProgress(10);

            try {
                updateStatus('Downloading data...');
                updateProgress(30);

                const response = await fetch(DATA_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const text = await response.text();
                updateStatus('Processing data...');
                updateProgress(60);

                let data;
                try {
                    // Pre-process the text to handle NaN values
                    const cleanedText = text.replace(/"account_badges":\s*NaN\s*,?/g, '"account_badges": null,');
                    data = JSON.parse(cleanedText);
                    if (!Array.isArray(data)) {
                        throw new Error('Data is not an array');
                    }
                } catch (parseError) {
                    console.error('JSON parse error:', parseError);
                    throw new Error('Failed to parse JSON data: ' + parseError.message);
                }
                
                updateStatus('Finalizing...');
                updateProgress(90);

                // Clean and process the data
                allData = data.filter(item => {
                    // Only include items that have required fields
                    return item && 
                           typeof item === 'object' && 
                           (item.userName || item.instagram_link) &&
                           Object.keys(item).length > 0;
                }).map((item, idx) => {
                    const obj = {
                        instagram_link: item.instagram_link || '',
                        userName: item.userName || '',
                        Category: item.Category || 'Uncategorized',
                        Description: item.Description || '',
                        followersCount: item.followersCount ? parseFloat(item.followersCount) : 0,
                        followsCount: item.followsCount ? parseFloat(item.followsCount) : 0,
                        followed_by: Array.isArray(item.followed_by) ? item.followed_by : [],
                        is_verified: Boolean(item.is_verified),
                        profile_pic_url: item.profile_pic_url || '',
                        full_name: item.full_name || ''
                    };
                    // Only add to originalOrderMap if we have a valid key
                    if (obj.userName || obj.instagram_link) {
                        originalOrderMap.set(obj.userName + '___' + obj.instagram_link, idx);
                    }
                    return obj;
                });

                updateStatus('Data loaded successfully!');
                updateProgress(100);

                // Initialize the app
                setTimeout(() => {
                    document.getElementById('loadNotice').style.display = 'none';
                    populateCategories();
                    updateStats();
                    updatePageRankScores(); // Calculate initial PageRank scores
                    filteredData = [...allData];
                    renderData();
                }, 500);

            } catch (error) {
                console.error('Error loading data:', error);
                updateStatus('Error loading data: ' + error.message);
                
                // Show error in the data grid
                document.getElementById('dataGrid').innerHTML = `
                    <div class="no-results">
                        <h3>Error Loading Data</h3>
                        <p>Could not load the Instagram data. Please check your connection and try refreshing the page.</p>
                        <p><small>Error: ${error.message}</small></p>
                    </div>
                `;
            }
        }

        function updateStatus(message) {
            document.getElementById('loadStatus').textContent = message;
        }

        function updateProgress(percent) {
            document.getElementById('progressFill').style.width = percent + '%';
        }

        function populateCategories() {
            const categories = [...new Set(allData.map(item => item.Category))]
                .filter(cat => cat && cat !== 'null' && cat !== 'Uncategorized')
                .sort();
                
            const select = document.getElementById('categoryFilter');
            select.innerHTML = '<option value="">All Categories</option>';
            
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                select.appendChild(option);
            });
        }

        function updateStats() {
            // Update followers section
            updateFollowersSection();
        }

        function updateFollowersSection() {
            // Get all unique followers from the followed_by arrays
            const allFollowers = new Set();
            allData.forEach(item => {
                if (item.followed_by && Array.isArray(item.followed_by)) {
                    item.followed_by.forEach(follower => allFollowers.add(follower));
                }
            });

            const followersGrid = document.getElementById('followersGrid');
            const followersSection = document.getElementById('followersSection');

            if (allFollowers.size > 0) {
                // Convert to array and sort
                const sortedFollowers = Array.from(allFollowers).sort();
                
                // Create follower elements with toggle functionality
                followersGrid.innerHTML = sortedFollowers.map(follower => {
                    const isSelected = selectedFollowers.has(follower);
                    return `<span class="follower-account ${isSelected ? 'selected' : ''}" onclick="toggleFollowerFilter('${follower}')">${isSelected ? 'âœ“ ' : ''}@${follower}</span>`;
                }).join('');
                
                followersSection.style.display = 'block';
            } else {
                followersSection.style.display = 'none';
            }
        }

        function toggleFollowerFilter(followerUsername) {
            if (selectedFollowers.has(followerUsername)) {
                selectedFollowers.delete(followerUsername);
            } else {
                selectedFollowers.add(followerUsername);
            }
            
            // Update the visual state
            updateFollowersSection();
            
            // Recalculate PageRank based on selected followers
            updatePageRankScores();
            
            // Apply the new filter
            applyFilters();
        }

        function searchForFollower(followerUsername) {
            // Set the search input to the follower's username
            document.getElementById('searchInput').value = followerUsername;
            // Apply filters to show results
            applyFilters();
            // Scroll to results
            document.getElementById('resultsCount').scrollIntoView({ behavior: 'smooth' });
        }

        function applyFilters() {
            if (allData.length === 0) return;

            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const categoryInput = document.getElementById('categoryFilter').value.trim().toLowerCase();
            // Split by comma, trim, and filter out empty strings
            const categoryTerms = categoryInput ? categoryInput.split(',').map(s => s.trim()).filter(Boolean) : [];
            const minFollowers = parseFloat(document.getElementById('minFollowers').value) || 0;
            const maxFollowers = parseFloat(document.getElementById('maxFollowers').value) || Infinity;

            filteredData = allData.filter(item => {
                const matchesSearch = !searchTerm || 
                    item.userName.toLowerCase().includes(searchTerm) ||
                    (item.Description && item.Description.toLowerCase().includes(searchTerm));

                // Category filter: if no terms, match all; else, match if any term is contained in the category (case-insensitive)
                const categoryValue = (item.Category || '').toLowerCase();
                const matchesCategory = categoryTerms.length === 0 || categoryTerms.some(term => categoryValue.includes(term));

                const matchesFollowers = item.followersCount >= minFollowers && item.followersCount <= maxFollowers;

                // New follower filter logic: if no followers selected, show all; else, only show accounts followed by selected followers
                const matchesFollowerFilter = selectedFollowers.size === 0 || 
                    (item.followed_by && Array.isArray(item.followed_by) && 
                     item.followed_by.some(follower => selectedFollowers.has(follower)));

                return matchesSearch && matchesCategory && matchesFollowers && matchesFollowerFilter;
            });

            // Apply sorting
            const sortBy = document.getElementById('sortBy').value;
            if (sortBy === 'original') {
                filteredData.sort((a, b) => {
                    const keyA = a.userName + '___' + a.instagram_link;
                    const keyB = b.userName + '___' + b.instagram_link;
                    return (originalOrderMap.get(keyA) ?? 0) - (originalOrderMap.get(keyB) ?? 0);
                });
            } else {
                filteredData.sort((a, b) => {
                    switch (sortBy) {
                        case 'pagerank_desc':
                            const scoreA = pageRankScores.get(a.userName) || 0;
                            const scoreB = pageRankScores.get(b.userName) || 0;
                            return scoreB - scoreA;
                        case 'pagerank_asc':
                            const scoreA_asc = pageRankScores.get(a.userName) || 0;
                            const scoreB_asc = pageRankScores.get(b.userName) || 0;
                            return scoreA_asc - scoreB_asc;
                        case 'followers_desc':
                            return b.followersCount - a.followersCount;
                        case 'followers_asc':
                            return a.followersCount - b.followersCount;
                        case 'username_asc':
                            return a.userName.localeCompare(b.userName);
                        case 'username_desc':
                            return b.userName.localeCompare(a.userName);
                        case 'following_desc':
                            return b.followsCount - a.followsCount;
                        case 'following_asc':
                            return a.followsCount - b.followsCount;
                        default:
                            return 0;
                    }
                });
            }

            currentPage = 1;
            renderData();
        }

        function renderData() {
            const resultsCount = document.getElementById('resultsCount');
            const dataGrid = document.getElementById('dataGrid');

            if (allData.length === 0) {
                resultsCount.textContent = 'Loading data...';
                return;
            }

            resultsCount.textContent = `Showing ${filteredData.length.toLocaleString()} results`;

            if (filteredData.length === 0) {
                dataGrid.innerHTML = `
                    <div class="no-results">
                        <h3>No results found</h3>
                        <p>Try adjusting your filters to see more results.</p>
                    </div>
                `;
                return;
            }

            // Paginate results
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, filteredData.length);
            const pageData = filteredData.slice(startIndex, endIndex);

            const cards = pageData.map(item => generateCardHtml(item)).join('');

            // Add load more button if there are more results
            const loadMoreButton = endIndex < filteredData.length ? `
                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn btn-primary" onclick="loadMore()">
                        Load More (${filteredData.length - endIndex} remaining)
                    </button>
                </div>
            ` : '';

            dataGrid.innerHTML = cards + loadMoreButton;
        }

        function loadMore() {
            currentPage++;
            
            const dataGrid = document.getElementById('dataGrid');
            const currentCards = dataGrid.innerHTML;
            
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, filteredData.length);
            const pageData = filteredData.slice(startIndex, endIndex);

            const newCards = pageData.map(item => generateCardHtml(item)).join('');

            const loadMoreButton = endIndex < filteredData.length ? `
                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn btn-primary" onclick="loadMore()">
                        Load More (${filteredData.length - endIndex} remaining)
                    </button>
                </div>
            ` : '';

            const cleanedContent = currentCards.replace(/<div style="text-align: center.*?<\/div>/s, '');
            dataGrid.innerHTML = cleanedContent + newCards + loadMoreButton;
        }

        function clearFilters() {
            document.getElementById('searchInput').value = '';
            document.getElementById('categoryFilter').value = '';
            document.getElementById('minFollowers').value = '';
            document.getElementById('maxFollowers').value = '';
            document.getElementById('sortBy').value = 'pagerank_desc';
            
            // Clear selected followers
            selectedFollowers.clear();
            updateFollowersSection();
            
            // Recalculate PageRank for all accounts
            updatePageRankScores();
            
            applyFilters();
        }

        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toLocaleString();
        }

        function generateCardHtml(item) {
            const followersText = item.followersCount > 0 ? formatNumber(item.followersCount) : 'N/A';
            const followingText = item.followsCount > 0 ? formatNumber(item.followsCount) : 'N/A';
            const category = item.Category && item.Category !== 'null' ? item.Category : 'Uncategorized';
            const description = item.Description || 'No description available';
            const pageRankScore = pageRankScores.get(item.userName) || 0;

            return `
                <div class="data-card">
                    <div class="card-header">
                        <a href="${item.instagram_link}" target="_blank" class="username">@${item.userName}</a>
                        <span class="followers-badge">${followersText}</span>
                    </div>
                    <div class="category">${category}</div>
                    <div class="description">${description.substring(0, 200)}${description.length > 200 ? '...' : ''}</div>
                    <div class="meta-info">
                        <div>
                            <span>Following: ${followingText}</span>
                            <span>â€¢</span>
                            <span>PageRank: ${pageRankScore.toFixed(1)}</span>
                            <span>â€¢</span>
                            <span><a href="${item.instagram_link}" target="_blank">View Profile</a></span>
                        </div>
                        ${item.followed_by.length > 0 ? `
                        <div>
                            <span style="color: #444;">Followed by:</span> ${item.followed_by.map(follower => `<span class="follower-tag">@${follower}</span>`).join(' ')}
                        </div>` : ''}
                    </div>
                </div>
            `;
        }

        // Add event listeners for real-time filtering
        document.getElementById('searchInput').addEventListener('input', applyFilters);
        document.getElementById('categoryFilter').addEventListener('input', applyFilters);
        document.getElementById('minFollowers').addEventListener('input', applyFilters);
        document.getElementById('maxFollowers').addEventListener('input', applyFilters);

        // Load data when page loads
        window.addEventListener('load', loadData);
    </script>
</body>
</html>
