<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Young Internet</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .test-mode-banner {
            background: linear-gradient(135deg, #ff6b6b 0%, #ff8e8e 100%);
            color: white;
            padding: 15px;
            margin: -10px -10px 20px -10px;
            border-radius: 12px;
            text-align: center;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .followers-section {
            background: white;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .section-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .section-header h2 {
            color: #333;
            margin-bottom: 5px;
            font-size: 1.8rem;
        }

        .section-header p {
            color: #666;
            font-size: 1rem;
        }

        .followers-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .follower-account {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
            text-decoration: none;
            transition: all 0.3s ease;
            display: inline-block;
            cursor: pointer;
        }

        .follower-account:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
            color: white;
            text-decoration: none;
        }

        .follower-account.selected {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            box-shadow: 0 3px 10px rgba(40, 167, 69, 0.3);
        }

        .follower-account.selected:hover {
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.5);
        }

        .filters {
            background: white;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 20px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-group label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #444;
        }

        .filter-group input, .filter-group select {
            padding: 12px;
            border: 2px solid #e1e1e1;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .filter-group input:focus, .filter-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .range-input {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .range-input input {
            flex: 1;
            /* Remove number input spinners/arrows for all browsers */
            -moz-appearance: textfield;
            appearance: textfield;
        }

        /* Chrome, Safari, Edge, Opera */
        .range-input input::-webkit-outer-spin-button,
        .range-input input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .filter-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #666;
            border: 2px solid #e1e1e1;
        }

        .btn-secondary:hover {
            background: #e9ecef;
        }

        .results {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .pagination {
            display:flex; gap:8px; align-items:center; flex-wrap:wrap;
        }
        .pagination button { padding:6px 12px; border:1px solid #ccc; background:#fff; border-radius:6px; cursor:pointer; }
        .pagination button.active { background:#667eea; color:#fff; border-color:#667eea; }
        .pagination span { font-size:0.85rem; color:#666; }

        .results-count {
            font-size: 1.2rem;
            font-weight: 600;
            color: #444;
        }

        .sort-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .sort-controls select {
            padding: 8px 12px;
            border: 2px solid #e1e1e1;
            border-radius: 8px;
            font-size: 14px;
        }

        .data-grid {
            display: grid;
            gap: 20px;
        }

        .data-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
            border: 1px solid #e1e1e1;
        }

        .data-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .username {
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
            text-decoration: none;
        }

        .username:hover {
            text-decoration: underline;
        }

        .followers-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .category {
            background: #e3f2fd;
            color: #1976d2;
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 0.85rem;
            margin-bottom: 10px;
            display: inline-block;
        }

        .description {
            color: #666;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .meta-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-size: 0.9rem;
            color: #888;
        }

        .meta-info > div:first-child {
            display: flex;
            gap: 20px;
        }

        .follower-tag {
            display: inline-block;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            color: #667eea;
            margin: 0 2px;
            font-size: 0.85rem;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .no-results {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .no-results h3 {
            margin-bottom: 10px;
            font-size: 1.5rem;
        }

        .load-notice {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            color: #0c5460;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #e1e1e1;
            border-radius: 5px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .filter-grid {
                grid-template-columns: 1fr;
            }

            .results-header {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Links -->
    <div style="position: fixed; top: 10px; right: 10px; z-index: 1000;">
        <a href="index.html" style="margin-right: 10px; padding: 8px 15px; background: rgba(255,255,255,0.95); border-radius: 8px; text-decoration: none; color: #333; font-weight: 600; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">📊 Explorer</a>
        <a href="database_updater_simple.html" style="padding: 8px 15px; background: rgba(255,255,255,0.95); border-radius: 8px; text-decoration: none; color: #333; font-weight: 600; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">⚙️ Updater</a>
    </div>

    <div class="container">
        <div class="header">
            <h1>The Young Internet</h1>
        </div>

        <!-- Test mode banner -->
        <div class="test-mode-banner" id="testModeBanner" style="display: none;">
            🔍 <strong>PREVIEW MODE</strong> - You are viewing updated data that hasn't been saved to the database yet
        </div>

        <div class="load-notice" id="loadNotice">
            🚀 <strong>Loading Data:</strong> Fetching your Instagram dataset...
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="loadStatus">Initializing...</div>
        </div>

        <div class="followers-section" id="followersSection" style="display: none;">
            <div class="section-header">
                <h2>Active Followers</h2>
                <p>Accounts that are following others in this dataset</p>
            </div>
            <div class="followers-grid" id="followersGrid">
                <!-- Follower accounts will be populated here -->
            </div>
        </div>

        <div class="filters">
            <div class="filter-grid">
                <div class="filter-group">
                    <label for="searchInput">Search Username or Description</label>
                    <input type="text" id="searchInput" placeholder="Type to search...">
                </div>

                <div class="filter-group">
                    <label for="categoryFilter">Category</label>
                    <input type="text" id="categoryFilter" placeholder="Type category keywords, separated by commas (e.g. singer, rapper)">
                </div>

                <div class="filter-group">
                    <label>Followers Range</label>
                    <div class="range-input">
                        <input type="number" id="minFollowers" placeholder="Min">
                        <span>to</span>
                        <input type="number" id="maxFollowers" placeholder="Max">
                    </div>
                </div>
                <!-- Removed Following Range filter group -->
            </div>

            <div class="filter-actions">
                <button class="btn btn-primary" onclick="applyFilters()">Apply Filters</button>
                <button class="btn btn-secondary" onclick="handleClearFilters()">Clear All</button>
            </div>
        </div>

        <div class="results">
            <div class="results-header">
                <div class="results-count" id="resultsCount">Loading data...</div>
                <div class="sort-controls">
                    <label for="sortBy">Sort by:</label>
                    <select id="sortBy" onchange="applyFilters()">
                        <option value="pagerank_desc">PageRank (High to Low)</option>
                        <option value="pagerank_asc">PageRank (Low to High)</option>
                        <option value="original">Original Order</option>
                        <option value="followers_desc">Followers (High to Low)</option>
                        <option value="followers_asc">Followers (Low to High)</option>
                        <option value="username_asc">Username (A-Z)</option>
                        <option value="username_desc">Username (Z-A)</option>
                        <option value="following_desc">Following (High to Low)</option>
                        <option value="following_asc">Following (Low to High)</option>
                    </select>
                </div>
                <div class="pagination" id="pagination"></div>
            </div>

            <div class="data-grid" id="dataGrid">
                <div class="loading">Loading Instagram data...</div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let allData = [];
        let filteredData = [];
        let selectedFollowers = new Set(); // Track which followers are selected for filtering
        let originalOrderMap = new Map();
        let pageRankScores = new Map(); // Store PageRank scores for each account
    let pageRankReady = false; // Indicates PageRank scores have been fetched
    let initialPageRankRendered = false; // Track if we've already done the first PR-ordered render
        let currentPage = 1;
        const itemsPerPage = 50;
        
        // Server-side pagination state
        let serverMode = false; // Will be true when API loads successfully
        let currentFilters = {};
        let isLoading = false;
        let hasMorePages = true;
        let totalServerRecords = 0;

        // Check for test mode
        const urlParams = new URLSearchParams(window.location.search);
        const isTestMode = urlParams.get('test') === 'true';
        const DATA_URL = isTestMode ? 'database_test.json' : 'database_mini.json';

        // Add test mode indicator
        if (isTestMode) {
            document.title = 'The Young Internet (TEST MODE)';
            document.body.style.borderTop = '5px solid orange';
            
            // Add visible indicator to header
            window.addEventListener('DOMContentLoaded', () => {
                const header = document.querySelector('.header h1');
                if (header) {
                    header.innerHTML += ' <span style="color: orange; font-size: 0.8em;">(TEST MODE)</span>';
                }
                const headerP = document.querySelector('.header p');
                if (headerP) {
                    headerP.innerHTML = '⚠️ <strong>TEST MODE:</strong> Previewing database changes - not the live data';
                    headerP.style.color = 'orange';
                }
            });
        }

        async function calculatePageRank(selectedFollowersSet = null) {
            console.log('=== Server-side PageRank Calculation Start ===');
            const selectedFollowers = selectedFollowersSet ? Array.from(selectedFollowersSet) : null;
            console.log('Selected followers:', selectedFollowers?.length || 'all');
            
            try {
                const response = await fetch('/api/pagerank', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        selectedFollowers: selectedFollowers
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (!result.success) {
                    throw new Error(result.error || 'PageRank calculation failed');
                }
                
                console.log('✅ PageRank calculation complete:', {
                    nodes: result.stats.nodes,
                    relationships: result.stats.relationships,
                    iterations: result.stats.iterations,
                    selectedCount: result.stats.selectedFollowersCount
                });
                
                // Convert scores object back to Map for compatibility
                const scoresMap = new Map();
                Object.entries(result.scores).forEach(([username, score]) => {
                    scoresMap.set(username, score);
                });
                
                console.log('=== Server-side PageRank Calculation End ===');
                return scoresMap;
                
            } catch (error) {
                console.error('❌ PageRank calculation error:', error);
                
                // Fallback to empty scores
                return new Map();
            }
        }

        // Legacy client-side PageRank function (kept as backup)
        function calculatePageRankClientSide(selectedFollowersSet = null) {
            console.log('=== Client-side PageRank Calculation Start ===');
            console.log('Selected followers:', selectedFollowersSet ? Array.from(selectedFollowersSet) : 'null');
            
            // Build the graph based on followed_by relationships
            const graph = new Map();
            const allUsernames = new Set();
            
            // Initialize graph and collect all usernames
            allData.forEach(item => {
                if (item.userName) {
                    allUsernames.add(item.userName);
                    graph.set(item.userName, new Set());
                }
            });
            
            console.log('Initial usernames in dataset:', allUsernames.size);
            
            // Build the follower graph
            let relationshipsProcessed = 0;
            allData.forEach(item => {
                if (item.followed_by && Array.isArray(item.followed_by)) {
                    item.followed_by.forEach(follower => {
                        // If we have selected followers, only consider their connections
                        // If no followers are selected (null or empty set), consider ALL relationships
                        const shouldInclude = selectedFollowersSet === null || 
                                            selectedFollowersSet.size === 0 || 
                                            selectedFollowersSet.has(follower);
                        
                        if (shouldInclude) {
                            relationshipsProcessed++;
                            // Ensure the follower exists in the graph
                            if (!graph.has(follower)) {
                                graph.set(follower, new Set());
                                allUsernames.add(follower);
                            }
                            // Add the relationship: follower -> item.userName
                            graph.get(follower).add(item.userName);
                        }
                    });
                }
            });
            
            console.log('Relationships processed:', relationshipsProcessed);
            console.log('Total nodes in graph:', allUsernames.size);
            
            const userList = Array.from(allUsernames);
            const n = userList.length;
            
            if (n === 0) return new Map();
            
            // Initialize PageRank scores
            const scores = new Map();
            const newScores = new Map();
            userList.forEach(user => {
                scores.set(user, 1.0 / n);
                newScores.set(user, 0);
            });
            
            // PageRank parameters
            const dampingFactor = 0.85;
            const iterations = 50;
            const tolerance = 1e-6;
            
            // Run PageRank algorithm
            for (let iter = 0; iter < iterations; iter++) {
                let totalDiff = 0;
                
                // Reset new scores
                userList.forEach(user => newScores.set(user, (1 - dampingFactor) / n));
                
                // Calculate new scores
                userList.forEach(fromUser => {
                    const outLinks = graph.get(fromUser) || new Set();
                    const outDegree = outLinks.size;
                    
                    if (outDegree > 0) {
                        const contribution = (dampingFactor * scores.get(fromUser)) / outDegree;
                        outLinks.forEach(toUser => {
                            newScores.set(toUser, newScores.get(toUser) + contribution);
                        });
                    }
                });
                
                // Check for convergence and update scores
                userList.forEach(user => {
                    const diff = Math.abs(newScores.get(user) - scores.get(user));
                    totalDiff += diff;
                    scores.set(user, newScores.get(user));
                });
                
                if (totalDiff < tolerance) {
                    console.log(`PageRank converged after ${iter + 1} iterations`);
                    break;
                }
            }
            
            // Normalize scores to 0-100 range for better display
            const maxScore = Math.max(...scores.values());
            const minScore = Math.min(...scores.values());
            const range = maxScore - minScore;
            
            if (range > 0) {
                scores.forEach((score, user) => {
                    scores.set(user, ((score - minScore) / range) * 100);
                });
            }
            
            // Log top 5 scores for debugging
            const topScores = Array.from(scores.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            console.log('Top 5 PageRank scores:', topScores);
            console.log('=== PageRank Calculation End ===');
            
            return scores;
        }

        async function updatePageRankScores() {
            // Only recalculate if we have selected followers (dynamic filtering)
            // For initial load, we use the persisted scores from the database
            if (selectedFollowers.size === 0 && pageRankReady) {
                console.log('📊 Using persisted PageRank scores from database');
                return;
            }
            
            const contextMsg = selectedFollowers.size === 0 ? 'all relationships' : `${selectedFollowers.size} selected followers`;
            console.log(`🔄 Starting PageRank calculation using ${contextMsg}...`);
            
            pageRankScores = await calculatePageRank(selectedFollowers);
            console.log(`✅ Calculated PageRank for ${pageRankScores.size} users using ${contextMsg}`);
            pageRankReady = pageRankScores.size > 0;
        }

        // Utility function for fetch with retry logic
        async function fetchWithRetry(url, options = {}, maxRetries = 3) {
            let lastError;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const response = await fetch(url, options);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    return response;
                } catch (error) {
                    lastError = error;
                    console.warn(`Fetch attempt ${attempt} failed:`, error.message);
                    
                    if (attempt < maxRetries) {
                        // Exponential backoff: 1s, 2s, 4s
                        const delay = Math.pow(2, attempt - 1) * 1000;
                        console.log(`Retrying in ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }
            
            throw new Error(`Failed after ${maxRetries} attempts: ${lastError.message}`);
        }

        async function loadData() {
            updateStatus('Connecting to data source...');
            updateProgress(10);

            try {
                let text;
                
                // Check if we're in test mode
                if (isTestMode) {
                    // First try to get data from sessionStorage (small datasets)
                    if (sessionStorage.getItem('testDatabaseData')) {
                        updateStatus('Loading preview data from sessionStorage...');
                        updateProgress(30);
                        text = sessionStorage.getItem('testDatabaseData');
                        updateStatus('Processing preview data...');
                        updateProgress(60);
                    } 
                    // Then try blob URL approach (large datasets)
                    else if (sessionStorage.getItem('testDatabaseInfo')) {
                        const previewInfo = JSON.parse(sessionStorage.getItem('testDatabaseInfo'));
                        if (previewInfo.useBlobUrl && previewInfo.blobUrl) {
                            updateStatus(`Loading large preview data (${previewInfo.dataSize} MB)...`);
                            updateProgress(20);
                            
                            try {
                                const response = await fetch(previewInfo.blobUrl);
                                if (!response.ok) {
                                    throw new Error('Blob URL no longer accessible');
                                }
                                text = await response.text();
                                updateStatus('Processing large preview dataset...');
                                updateProgress(60);
                            } catch (blobError) {
                                throw new Error(`Failed to load preview data via blob URL: ${blobError.message}`);
                            }
                        }
                    }
                    // Fallback to regular database if no test data found
                    else {
                        updateStatus('No preview data found, loading regular database...');
                        updateProgress(30);
                        const response = await fetch(DATA_URL);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        text = await response.text();
                        updateStatus('Processing data...');
                        updateProgress(60);
                    }
                } else {
                    // Normal mode - load from database API or fallback to JSON
                    updateStatus('Connecting to database...');
                    updateProgress(30);

                    try {
                        // Try database API first with retry logic
                        // Now that PageRank is persisted server-side (pagerank_score column), request sorted by it
                        updateStatus('Connecting to database...');
                        const response = await fetchWithRetry('/api/accounts?limit=50&sort=pagerank_score&order=DESC');
                        const result = await response.json();
                        const data = result.accounts;
                        
                        // Set server mode and totals
                        serverMode = true;
                        totalServerRecords = result.total;
                        hasMorePages = data.length === 50;
                        
                        updateStatus(`Loaded ${data.length} records from database (${result.total} total available)`);
                        updateProgress(90);

                        // Process the data 
                        allData = data.filter(item => {
                            return item && 
                                   typeof item === 'object' && 
                                   (item.userName || item.instagram_link) &&
                                   Object.keys(item).length > 0;
                        });

                        updateStatus(`Processed ${allData.length} valid records (${totalServerRecords} total in database)`);
                        updateProgress(100);

                        // Prepare for initial render
                        filteredData = allData.slice();
                        populateCategories();
                        updateStats();
                        
                        // Use persisted PageRank scores from database instead of recalculating
                        // This avoids the expensive API call on initial load
                        pageRankScores = new Map();
                        allData.forEach(item => {
                            if (item.pagerank_score && item.userName) {
                                pageRankScores.set(item.userName, parseFloat(item.pagerank_score));
                            }
                        });
                        pageRankReady = true;
                        
                        // Data is already sorted by pagerank_score from the API call
                        // So we don't need to sort again, just render
                        document.getElementById('resultsCount').textContent = `Showing ${filteredData.length} results (${totalServerRecords} total found)`;
                        renderData();
                        initialPageRankRendered = true;
                        return; // Skip applyFilters() on initial load (already rendered in PageRank order)
                    } catch (apiError) {
                        console.error('Database API failed:', apiError.message);
                        
                        // Show retry-friendly error
                        throw new Error(`Unable to load data: ${apiError.message}. Please try refreshing the page.`);
                    }
                }

            } catch (error) {
                console.error('Error loading data:', error);
                updateStatus('Error loading data: ' + error.message);
                
                // Show error in the data grid with retry option
                document.getElementById('dataGrid').innerHTML = `
                    <div class="no-results">
                        <h3>Error Loading Data</h3>
                        <p>Could not load the Instagram data. Please check your connection and try again.</p>
                        <p><small>Error: ${error.message}</small></p>
                        <button onclick="loadData()" style="margin-top: 10px; padding: 10px 20px; background-color: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Retry Loading Data
                        </button>
                    </div>
                `;
            }
        }

        function updateStatus(message) {
            document.getElementById('loadStatus').textContent = message;
        }

        function updateProgress(percent) {
            document.getElementById('progressFill').style.width = percent + '%';
        }

        function populateCategories() {
            const categories = [...new Set(allData.map(item => item.Category))]
                .filter(cat => cat && cat !== 'null' && cat !== 'Uncategorized')
                .sort();
                
            const select = document.getElementById('categoryFilter');
            select.innerHTML = '<option value="">All Categories</option>';
            
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                select.appendChild(option);
            });
        }

        function updateStats() {
            // Update followers section
            updateFollowersSection();
        }

        function updateFollowersSection() {
            // Get all unique followers from the followed_by arrays
            const allFollowers = new Set();
            allData.forEach(item => {
                if (item.followed_by && Array.isArray(item.followed_by)) {
                    item.followed_by.forEach(follower => allFollowers.add(follower));
                }
            });

            const followersGrid = document.getElementById('followersGrid');
            const followersSection = document.getElementById('followersSection');

            if (allFollowers.size > 0) {
                // Convert to array and sort
                const sortedFollowers = Array.from(allFollowers).sort();
                
                // Create follower elements with toggle functionality
                followersGrid.innerHTML = sortedFollowers.map(follower => {
                    const isSelected = selectedFollowers.has(follower);
                    return `<span class="follower-account ${isSelected ? 'selected' : ''}" onclick="handleToggleFollowerFilter('${follower}')">${isSelected ? '✓ ' : ''}@${follower}</span>`;
                }).join('');
                
                followersSection.style.display = 'block';
            } else {
                followersSection.style.display = 'none';
            }
        }

        async function toggleFollowerFilter(followerUsername) {
            if (selectedFollowers.has(followerUsername)) {
                selectedFollowers.delete(followerUsername);
            } else {
                selectedFollowers.add(followerUsername);
            }
            
            // Update the visual state
            updateFollowersSection();
            
            // Recalculate PageRank based on selected followers
            await updatePageRankScores();
            
            // Apply the new filter
            applyFilters();
        }

        function searchForFollower(followerUsername) {
            // Set the search input to the follower's username
            document.getElementById('searchInput').value = followerUsername;
            // Apply filters to show results
            applyFilters();
            // Scroll to results
            document.getElementById('resultsCount').scrollIntoView({ behavior: 'smooth' });
        }

        function applyFilters() {
            // Skip auto-run right after initial PageRank render
            if (!serverMode && initialPageRankRendered === true) {
                // continue; client JSON mode unaffected
            }
            if (!serverMode) {
                // Fallback to client-side filtering for JSON mode
                return applyFiltersClientSide();
            }

            // Server-side filtering: simple approach
            const searchTerm = document.getElementById('searchInput').value.trim();
            const categoryInput = document.getElementById('categoryFilter').value.trim();
            const minFollowers = document.getElementById('minFollowers').value.trim() || '0';
            const maxFollowers = document.getElementById('maxFollowers').value.trim() || '999999999';
            const sortValue = document.getElementById('sortBy').value;
            
            // Map sort values to API parameters
            const sortMap = {
                'followers_desc': 'followers_count',
                'followers_asc': 'followers_count', 
                'username_asc': 'username',
                'username_desc': 'username',
                'pagerank_desc': 'pagerank_score',
                'pagerank_asc': 'pagerank_score'
            };
            // For PageRank we currently sort client-side after fetching (scores are from separate endpoint)
            const sortCol = sortValue.startsWith('pagerank_') ? 'followers_count' : (sortMap[sortValue] || 'followers_count');
            const sortDir = sortValue.includes('_asc') ? 'ASC' : 'DESC';
            
            // Build query parameters
            const params = new URLSearchParams({
                limit: '50',
                offset: '0',
                search: searchTerm,
                category: categoryInput,
                min_followers: minFollowers,
                max_followers: maxFollowers,
                sort: sortCol,
                order: sortDir
            });
            
            // Fetch filtered results
            fetch('/api/accounts?' + params.toString())
                .then(response => response.json())
                .then(result => {
                    allData = result.accounts || [];
                    totalServerRecords = result.total || 0;
                    hasMorePages = allData.length === 50;
                    
                    document.getElementById('resultsCount').textContent = 
                        `Showing ${allData.length} results (${result.total} total found)`;
                    
                    // Reset pagination
                    currentPage = 1;
                    filteredData = allData.slice();

                    // Client-side PageRank sort if requested and scores ready
                    if (pageRankReady && sortValue === 'pagerank_desc') {
                        filteredData.sort((a,b) => (pageRankScores.get(b.userName)||0) - (pageRankScores.get(a.userName)||0));
                    } else if (pageRankReady && sortValue === 'pagerank_asc') {
                        filteredData.sort((a,b) => (pageRankScores.get(a.userName)||0) - (pageRankScores.get(b.userName)||0));
                    }
                    renderData();
                    if (!initialPageRankRendered && pageRankReady) {
                        // Ensure order consistent if user triggers a filter quickly
                        filteredData.sort((a,b) => (pageRankScores.get(b.userName)||0) - (pageRankScores.get(a.userName)||0));
                        renderData();
                        initialPageRankRendered = true;
                    }
                })
                .catch(error => {
                    console.error('Filter error:', error);
                    // Fall back to client-side
                    serverMode = false;
                    applyFiltersClientSide();
                });
        }

        function applyFiltersClientSide() {
            // Original client-side logic for JSON fallback
            if (allData.length === 0) return;

            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const categoryInput = document.getElementById('categoryFilter').value.trim().toLowerCase();
            const categoryTerms = categoryInput ? categoryInput.split(',').map(s => s.trim()).filter(Boolean) : [];
            const minFollowers = parseFloat(document.getElementById('minFollowers').value) || 0;
            const maxFollowers = parseFloat(document.getElementById('maxFollowers').value) || Infinity;

            filteredData = allData.filter(item => {
                const matchesSearch = !searchTerm || 
                    item.userName.toLowerCase().includes(searchTerm) ||
                    (item.Description && item.Description.toLowerCase().includes(searchTerm));

                const categoryValue = (item.Category || '').toLowerCase();
                const matchesCategory = categoryTerms.length === 0 || categoryTerms.some(term => categoryValue.includes(term));

                const matchesFollowers = item.followersCount >= minFollowers && item.followersCount <= maxFollowers;

                const matchesFollowerFilter = selectedFollowers.size === 0 || 
                    (item.followed_by && Array.isArray(item.followed_by) && 
                     item.followed_by.some(follower => selectedFollowers.has(follower)));

                return matchesSearch && matchesCategory && matchesFollowers && matchesFollowerFilter;
            });

            // Apply sorting
            const sortBy = document.getElementById('sortBy').value;
            if (sortBy === 'original') {
                filteredData.sort((a, b) => {
                    const keyA = a.userName + '___' + a.instagram_link;
                    const keyB = b.userName + '___' + b.instagram_link;
                    return (originalOrderMap.get(keyA) ?? 0) - (originalOrderMap.get(keyB) ?? 0);
                });
            } else {
                filteredData.sort((a, b) => {
                    switch (sortBy) {
                        case 'pagerank_desc':
                            const scoreA = pageRankScores.get(a.userName) || 0;
                            const scoreB = pageRankScores.get(b.userName) || 0;
                            return scoreB - scoreA;
                        case 'pagerank_asc':
                            const scoreA_asc = pageRankScores.get(a.userName) || 0;
                            const scoreB_asc = pageRankScores.get(b.userName) || 0;
                            return scoreA_asc - scoreB_asc;
                        case 'followers_desc':
                            return b.followersCount - a.followersCount;
                        case 'followers_asc':
                            return a.followersCount - b.followersCount;
                        case 'username_asc':
                            return a.userName.localeCompare(b.userName);
                        case 'username_desc':
                            return b.userName.localeCompare(a.userName);
                        case 'following_desc':
                            return b.followsCount - a.followsCount;
                        case 'following_asc':
                            return a.followsCount - b.followsCount;
                        default:
                            return 0;
                    }
                });
            }

            currentPage = 1;
            renderData();
        }

        async function loadMoreResults(isNewSearch = false) {
            if (isLoading || (!hasMorePages && !isNewSearch)) return;
            
            isLoading = true;
            const limit = isNewSearch ? 50 : 50; // Start with smaller batches
            const offset = isNewSearch ? 0 : allData.length;
            
            try {
                const params = new URLSearchParams({ 
                    ...currentFilters, 
                    limit: String(limit), 
                    offset: String(offset) 
                });
                
                // Add timeout for server requests
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
                
                const response = await fetch('/api/accounts?' + params.toString(), {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) throw new Error('HTTP ' + response.status);
                
                const result = await response.json();
                const newData = result.accounts || [];
                
                if (isNewSearch) {
                    allData = newData;
                    totalServerRecords = result.total;
                    document.getElementById('resultsCount').textContent = `Showing ${newData.length} results (${result.total} total found)`;
                } else {
                    allData.push(...newData);
                    document.getElementById('resultsCount').textContent = `Showing ${allData.length} results (${result.total} total found)`;
                }
                
                hasMorePages = newData.length === limit; // If we got less than limit, no more pages
                filteredData = allData.slice(); // All loaded data is already filtered by server
                renderData();
                
            } catch (error) {
                console.error('Failed to load more results:', error);
                if (isNewSearch) {
                    // Fallback to client-side on search failure
                    serverMode = false;
                    applyFiltersClientSide();
                }
            } finally {
                isLoading = false;
            }
        }

        function renderData() {
            const resultsCount = document.getElementById('resultsCount');
            const dataGrid = document.getElementById('dataGrid');

            if (allData.length === 0) {
                if (!serverMode) resultsCount.textContent = 'Loading data...';
                dataGrid.innerHTML = `
                    <div class="no-results">
                        <h3>Loading...</h3>
                        <p>Please wait while data loads.</p>
                    </div>
                `;
                return;
            }

            // For server mode, show message set by search/filter functions
            if (!serverMode) {
                resultsCount.textContent = `Showing ${allData.length.toLocaleString()} results`;
            }

            if (allData.length === 0) {
                dataGrid.innerHTML = `
                    <div class="no-results">
                        <h3>No results found</h3>
                        <p>Try adjusting your filters to see more results.</p>
                    </div>
                `;
                return;
            }

            // Show all loaded data (simplified - no complex pagination)
            const cards = allData.map(item => generateCardHtml(item)).join('');

            // Add scroll loading indicator if server mode
            let bottomContent = '';
            if (serverMode && hasMorePages) {
                bottomContent = `
                    <div id="loadingIndicator" style="text-align: center; margin-top: 30px; padding: 20px; color: #666;">
                        Scroll down for more results
                    </div>
                `;
            }

            dataGrid.innerHTML = cards + bottomContent;
        }

        function loadMoreClientSide() {
            // Original client-side load more logic
            currentPage++;
            
            const dataGrid = document.getElementById('dataGrid');
            const currentCards = dataGrid.innerHTML;
            
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, filteredData.length);
            const pageData = filteredData.slice(startIndex, endIndex);

            const newCards = pageData.map(item => generateCardHtml(item)).join('');

            const loadMoreButton = endIndex < filteredData.length ? `
                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn btn-primary" onclick="loadMoreClientSide()">
                        Load More (${filteredData.length - endIndex} remaining)
                    </button>
                </div>
            ` : '';

            const cleanedContent = currentCards.replace(/<div style="text-align: center.*?<\/div>/s, '');
            dataGrid.innerHTML = cleanedContent + newCards + loadMoreButton;
        }

        async function clearFilters() {
            document.getElementById('searchInput').value = '';
            document.getElementById('categoryFilter').value = '';
            document.getElementById('minFollowers').value = '';
            document.getElementById('maxFollowers').value = '';
            document.getElementById('sortBy').value = 'pagerank_desc';
            
            // Clear selected followers
            selectedFollowers.clear();
            updateFollowersSection();
            
            // Recalculate PageRank for all accounts
            await updatePageRankScores();
            
            applyFilters();
        }

        // Wrapper functions for onclick handlers (can't use async/await directly in HTML)
        function handleToggleFollowerFilter(followerUsername) {
            toggleFollowerFilter(followerUsername).catch(console.error);
        }

        function handleClearFilters() {
            clearFilters().catch(console.error);
        }

        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toLocaleString();
        }

        function generateCardHtml(item) {
            const followersText = item.followersCount > 0 ? formatNumber(item.followersCount) : 'N/A';
            const followingText = item.followsCount > 0 ? formatNumber(item.followsCount) : 'N/A';
            const category = item.Category && item.Category !== 'null' ? item.Category : 'Uncategorized';
            const description = item.Description || 'No description available';
            const pageRankScore = pageRankScores.get(item.userName) || 0;
            const displayPR = pageRankScore || item.pagerank_score || 0;

            return `
                <div class="data-card">
                    <div class="card-header">
                        <a href="${item.instagram_link}" target="_blank" class="username">@${item.userName}</a>
                        <span class="followers-badge">${followersText}</span>
                    </div>
                    <div class="category">${category}</div>
                    <div class="description">${description.substring(0, 200)}${description.length > 200 ? '...' : ''}</div>
                    <div class="meta-info">
                        <div>
                            <span>Following: ${followingText}</span>
                            <span>•</span>
                            <span>PageRank: ${displayPR.toFixed(1)}</span>
                            <span>•</span>
                            <span><a href="${item.instagram_link}" target="_blank">View Profile</a></span>
                        </div>
                        ${item.followed_by.length > 0 ? `
                        <div>
                            <span style="color: #444;">Followed by:</span> ${item.followed_by.map(follower => {
                                const isSelected = selectedFollowers.has(follower);
                                return `<span class="follower-tag" style="${isSelected ? 'background: #28a745; color: white; font-weight: 600;' : ''}">@${follower}</span>`;
                            }).join(' ')}
                        </div>` : ''}
                    </div>
                </div>
            `;
        }

        // Add event listeners for real-time filtering
        document.getElementById('searchInput').addEventListener('input', applyFilters);
        document.getElementById('categoryFilter').addEventListener('input', applyFilters);
        document.getElementById('minFollowers').addEventListener('input', applyFilters);
        document.getElementById('maxFollowers').addEventListener('input', applyFilters);

        // Add infinite scroll listener
        let scrollTimeout;
        window.addEventListener('scroll', () => {
            if (!serverMode || !hasMorePages || isLoading) return;
            
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                const scrollPosition = window.innerHeight + window.scrollY;
                const documentHeight = document.documentElement.scrollHeight;
                
                // Load more when user is 500px from bottom
                if (scrollPosition >= documentHeight - 500) {
                    loadMoreResults(false);
                }
            }, 100); // Debounce scroll events
        });

        // Load data when page loads
        window.addEventListener('load', loadData);
    </script>
</body>
</html>
